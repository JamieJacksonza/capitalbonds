import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function getAdmin() {
  const url = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) throw new Error("Missing SUPABASE_URL (or NEXT_PUBLIC_SUPABASE_URL) or SUPABASE_SERVICE_ROLE_KEY");
  return createClient(url, key, {
    auth: { persistSession: false, autoRefreshToken: false },
  });
}

function normStage(v: any) {
  return String(v || "").trim().toLowerCase();
}

function pickFirst(objA: any, objB: any, keys: string[]) {
  for (const k of keys) {
    const v = objA?.[k];
    if (v !== undefined) return v;
    const v2 = objB?.[k];
    if (v2 !== undefined) return v2;
  }
  return undefined;
}

function toBoolOrNull(v: any) {
  if (v === true || v === false) return v;
  const s = String(v ?? "").trim().toLowerCase();
  if (!s) return null;
  if (s === "true" || s === "yes" || s === "y" || s === "1") return true;
  if (s === "false" || s === "no" || s === "n" || s === "0") return false;
  return null;
}

async function handle(req: NextRequest) {
  const body = await req.json().catch(() => ({} as any));
  console.log('MOVE DEBUG bodyKeys=', Object.keys(body||{}), 'stageDataType=', typeof (body as any)?.stageData, 'stageDataKeys=', ((body as any)?.stageData && typeof (body as any).stageData === 'object') ? Object.keys((body as any).stageData) : null);

  const dealId = body?.dealId ?? body?.deal_id ?? body?.id;
  const toStageRaw = body?.toStage ?? body?.to_stage ?? body?.stage;
  const movedBy = body?.movedBy ?? body?.moved_by ?? body?.actor ?? null;
  const note = body?.note ?? body?.notes ?? null;

  const toStage = normStage(toStageRaw);

  if (!dealId || !toStage) {
    return NextResponse.json({ ok: false, error: "Missing dealId/id and/or toStage" }, { status: 400 });
  }

  const supabase = getAdmin();

  // Load current deal stage + move_history
  const { data: cur, error: curErr } = await supabase
    .from("deals")
    .select("id, stage, move_history")
    .eq("id", dealId)
    .single();

  if (curErr || !cur) {
    return NextResponse.json({ ok: false, error: curErr?.message || "Deal not found" }, { status: 404 });
  }

  const fromStage = normStage((cur as any)?.stage);

  // Stage data: prefer explicit stageData/stage_data, otherwise capture any extra keys in the request body
  const stageDataExplicit =
    (body?.stageData && typeof body.stageData === "object" ? body.stageData : null) ||
    (body?.stage_data && typeof body.stage_data === "object" ? body.stage_data : null);

  const reserved = new Set([
    "dealId",
    "deal_id",
    "id",
    "toStage",
    "to_stage",
    "stage",
    "movedBy",
    "moved_by",
    "actor",
    "note",
    "notes",
    "stageData",
    "stage_data",
  ]);

  const extra = Object.fromEntries(Object.entries(body || {}).filter(([k]) => !reserved.has(k)));
  const stageData =
  (body as any)?.data ??
  (body as any)?.stageData ??
  (body as any)?.stage_data ??
  (body as any)?.computedStageData ??
  (body as any)?.computedStagePayload ??
  (body as any)?.stagePayload ??
  (body as any)?.stage_payload ??
  (body as any)?.payload?.data ??
  (body as any)?.payload?.stageData ??
  null;
const nowIso = new Date().toISOString();

  // Build deal updates (safe columns only)
  const updates: any = {
    stage: toStage,
    updated_at: nowIso,
    last_moved_at: nowIso,
    last_moved_by: movedBy,
  };

  // Persist a few known deal columns if present (columns seen in your /api/deals/:id output)
  const attorneyVal = pickFirst(stageData, body, ["attorney", "Attorney"]);
  if (attorneyVal !== undefined) updates.attorney = attorneyVal ? String(attorneyVal) : null;

  const regNum = pickFirst(stageData, body, ["registration_number", "registrationNumber", "regNumber"]);
  if (regNum !== undefined) updates.registration_number = regNum ? String(regNum) : null;

  const regAtt = pickFirst(stageData, body, ["registration_attorney", "registrationAttorney", "attorneyName"]);
  if (regAtt !== undefined) updates.registration_attorney = regAtt ? String(regAtt) : null;

  // NOTE: your deal object includes BOTH registration_attorney_tel AND registration_attorney_contact
  // We'll prefer writing to registration_attorney_tel, but also mirror to registration_attorney_contact if it exists.
  const regTel = pickFirst(stageData, body, [
    "registration_attorney_tel",
    "registrationAttorneyTel",
    "registration_attorney_contact",
    "registrationAttorneyContact",
    "attorneyTel",
    "attorneyContact",
  ]);
  if (regTel !== undefined) {
    const v = regTel ? String(regTel) : null;
    updates.registration_attorney_tel = v;
    updates.registration_attorney_contact = v;
  }

  const regEmail = pickFirst(stageData, body, ["registration_attorney_email", "registrationAttorneyEmail", "attorneyEmail"]);
  if (regEmail !== undefined) updates.registration_attorney_email = regEmail ? String(regEmail) : null;

  const regRef = pickFirst(stageData, body, ["registration_attorney_reference", "registrationAttorneyReference", "attorneyReference", "reference"]);
  if (regRef !== undefined) updates.registration_attorney_reference = regRef ? String(regRef) : null;

  const due = pickFirst(stageData, body, ["payment_due_date", "paymentDueDate", "dueDate"]);
  if (due !== undefined) updates.payment_due_date = due ? String(due).slice(0, 10) : null;

  const comm = pickFirst(stageData, body, ["agent_comm_paid", "agentCommPaid", "commissionPaid"]);
  if (comm !== undefined) updates.agent_comm_paid = toBoolOrNull(comm);

  // Append move_history entry WITH data (so we can show it in cards without DB schema changes)
  const prev = Array.isArray((cur as any)?.move_history) ? (cur as any).move_history : [];
  const entry: any = {
    at: nowIso,
    by: movedBy,
    from: fromStage || null,
    to: toStage,
    note: typeof note === "string" && note.trim() ? note.trim() : null,
  };

  if (stageData && typeof stageData === "object" && Object.keys(stageData).length) {
    entry.data = stageData;
  }

  updates.move_history = [...prev, entry];

  const { error: upErr } = await supabase.from("deals").update(updates).eq("id", dealId);
  if (upErr) {
    return NextResponse.json({ ok: false, error: upErr.message }, { status: 500 });
  }

  // Log into deal_activity (your UI uses this)
  await supabase.from("deal_activity").insert({
    deal_id: dealId,
    action: "move",
    from_stage: fromStage || null,
    to_stage: toStage,
    moved_by: movedBy,
    moved_at: nowIso,
    note: typeof note === "string" && note.trim() ? note.trim() : null,
  });

  return NextResponse.json({ ok: true });
}

export async function POST(req: NextRequest) {
  return handle(req);
}

export async function PATCH(req: NextRequest) {
  return handle(req);
}





