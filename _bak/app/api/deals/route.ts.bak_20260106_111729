import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const runtime = "nodejs";

function admin() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) throw new Error("Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
  return createClient(url, key, { auth: { persistSession: false } });
}

function isUuid(v: string) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);
}

function normalizeStage(s: any) {
  const v = String(s ?? "").trim().toLowerCase();
  if (!v) return "";
  if (v === "arp") return "aip";
  if (v === "instructions" || v === "instruct") return "instructed";
  if (v === "registration" || v === "regs" || v === "reg") return "registrations";
  if (v === "grant" || v === "approved") return "granted";
  return v;
}

function asArray(v: any): any[] {
  if (!v) return [];
  if (Array.isArray(v)) return v;
  if (typeof v === "string") {
    try {
      const parsed = JSON.parse(v);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }
  return [];
}

async function findDeal(sb: ReturnType<typeof admin>, target: string) {
  const t = String(target || "").trim();
  if (!t) return { deal: null as any, error: "Missing deal id/code" };

  const q = sb.from("deals").select("*").limit(1);
  const res = isUuid(t) ? await q.eq("id", t) : await q.eq("deal_code", t);

  if (res.error) return { deal: null as any, error: res.error.message };
  const deal = res.data?.[0] ?? null;
  if (!deal) return { deal: null as any, error: "Deal not found" };
  return { deal, error: null as any };
}

async function attachBanks(sb: ReturnType<typeof admin>, deals: any[]) {
  const ids = deals.map((d) => d?.id).filter(Boolean);
  const banksById = new Map<string, any[]>();

  const chunkSize = 400;
  for (let i = 0; i < ids.length; i += chunkSize) {
    const chunk = ids.slice(i, i + chunkSize);
    const { data } = await sb
      .from("deal_banks")
      .select("deal_id, bank_name")
      .in("deal_id", chunk);

    (data || []).forEach((row: any) => {
      const k = String(row.deal_id);
      if (!banksById.has(k)) banksById.set(k, []);
      banksById.get(k)!.push({ bank_name: row.bank_name });
    });
  }

  return deals.map((d) => ({
    ...d,
    banks: banksById.get(String(d.id)) || [],
  }));
}

export async function GET(req: Request) {
  const sb = admin();
  const url = new URL(req.url);
  const stageQ = normalizeStage(url.searchParams.get("stage"));

  let q = sb.from("deals").select("*").order("submitted_date", { ascending: false }).order("created_at", { ascending: false }).limit(2000);
  if (stageQ) q = q.eq("stage", stageQ);

  const { data, error } = await q;
  if (error) return NextResponse.json({ ok: false, error: error.message }, { status: 500 });

  const deals = await attachBanks(sb, data || []);
  return NextResponse.json({ ok: true, deals, data: deals });
}

export async function PATCH(req: Request) {
  const sb = admin();
  const body = await req.json().catch(() => ({} as any));

  const target =
    String(body?.id ?? body?.deal_id ?? body?.dealCode ?? body?.deal_code ?? "").trim();

  const { deal, error } = await findDeal(sb, target);
  if (error) return NextResponse.json({ ok: false, error }, { status: 404 });

  const now = new Date().toISOString();

  const nextStageRaw = body?.toStage ?? body?.stage;
  const nextStage = normalizeStage(nextStageRaw);
  const noteText = String(body?.note ?? "").trim();
  const movedBy = String(body?.movedBy ?? body?.moved_by ?? body?.user ?? "").trim() || null;

  const moveHistory = asArray(deal.move_history);
  const notesHistory = asArray(deal.notes_history);

  const update: Record<string, any> = {};

  // Allow updating some fields (safe subset)
  const allow = new Set([
    "notes",
    "registration_number",
    "registration_attorney",
    "registration_attorney_tel",
    "registration_attorney_contact",
    "agent_comm_paid",
    "payment_due_date",
  ]);

  Object.keys(body || {}).forEach((k) => {
    if (allow.has(k)) update[k] = body[k];
  });

  // Stage move: log + update
  if (nextStage && String(nextStage) !== String(deal.stage ?? "")) {
    moveHistory.push({
      at: now,
      by: movedBy,
      from: deal.stage ?? null,
      to: nextStage,
      note: noteText || null,
    });

    update.stage = nextStage;
    update.last_moved_at = now;
    update.last_moved_by = movedBy;
    update.move_history = moveHistory;
  }

  // Notes: log dated note entries (even if stage didn't change)
  if (noteText) {
    notesHistory.push({
      at: now,
      by: movedBy,
      stage: nextStage || deal.stage || null,
      note: noteText,
    });

    update.notes = noteText; // keep latest note in the main notes column too
    update.notes_history = notesHistory;
  }

  const { data: updatedRows, error: upErr } = await sb
    .from("deals")
    .update(update)
    .eq("id", deal.id)
    .select("*")
    .limit(1);

  if (upErr) return NextResponse.json({ ok: false, error: upErr.message }, { status: 500 });

  const updated = updatedRows?.[0] ?? null;
  return NextResponse.json({ ok: true, deal: updated, data: updated });
}