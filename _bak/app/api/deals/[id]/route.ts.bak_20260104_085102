import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic";

function getSupabase() {
  const url =
    process.env.NEXT_PUBLIC_SUPABASE_URL ||
    process.env.SUPABASE_URL ||
    "";

  const key =
    process.env.SUPABASE_SERVICE_ROLE_KEY ||
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ||
    process.env.SUPABASE_ANON_KEY ||
    "";

  if (!url || !key) throw new Error("Missing Supabase env vars (URL/KEY). Check .env.local");
  return createClient(url, key, { auth: { persistSession: false } });
}

function normalizeDealPatchShape(raw: any) {
  if (!raw || typeof raw !== "object") return {};
  const out: any = { ...raw };

  // Backwards compat: { nextStage, note }
  if ("nextStage" in out && !("stage" in out)) out.stage = out.nextStage;
  if ("nextStage" in out) delete out.nextStage;

  // Backwards compat: move note -> notes (but never let blank wipe notes)
  if ("note" in out) {
    const note = String(out.note ?? "").trim();
    if (note && !("notes" in out)) out.notes = note;
    delete out.note;
  }

  return out;
}

function sanitizeDealPatch(input: any) {
  if (!input || typeof input !== "object") return {};
  const out: any = { ...input };

  // Strip nested objects that are NOT columns on deals table
  if ("banks" in out) delete out.banks;

  // Prevent accidental blank wipe on notes
  if ("notes" in out && typeof out.notes === "string" && out.notes.trim() === "") delete out.notes;

  // Dates: Supabase date columns cannot accept ""
  const dateKeys = ["submitted_date", "payment_due_date"];
  for (const k of dateKeys) if (k in out && (out[k] === "" || out[k] === undefined)) out[k] = null;

  // Timestamps: also cannot accept ""
  const tsKeys = ["last_moved_at"];
  for (const k of tsKeys) if (k in out && (out[k] === "" || out[k] === undefined)) out[k] = null;

  // Numbers: "" -> null, numeric strings -> number
  const numKeys = ["amount_zar", "amount"];
  for (const k of numKeys) {
    if (k in out) {
      const v = out[k];
      if (v === "" || v === undefined) out[k] = null;
      else if (typeof v === "string" && v.trim() !== "" && !Number.isNaN(Number(v))) out[k] = Number(v);
    }
  }

  // Booleans: "true"/"false" -> boolean, "" -> null
  const boolKeys = ["agent_comm_paid"];
  for (const k of boolKeys) {
    if (k in out) {
      const v = out[k];
      if (v === "" || v === undefined) out[k] = null;
      else if (v === "true") out[k] = true;
      else if (v === "false") out[k] = false;
    }
  }

  // Don't allow client to set server-managed timestamps
  if ("created_at" in out) delete out.created_at;
  if ("updated_at" in out) delete out.updated_at;

  return out;
}

async function getIdFromCtx(ctx: any) {
  const params = await (ctx as any)?.params;
  const raw = String(params?.id ?? "").trim();
  let id = raw;
  try { id = decodeURIComponent(raw); } catch {}
  return id.trim();
}

async function loadBanks(supabase: any, dealId: string) {
  const candidates = ["banks", "deal_banks", "dealBanks"];
  let lastErr: any = null;

  for (const table of candidates) {
    const r = await supabase.from(table).select("*").eq("deal_id", dealId);
    if (!r.error) return { table, rows: r.data ?? [] };
    lastErr = r.error;

    const msg = String(r.error?.message ?? "").toLowerCase();
    if (msg.includes("does not exist") || msg.includes("relation") || (msg.includes("column") && msg.includes("does not exist"))) continue;

    return { table, rows: [], error: r.error };
  }

  return { table: candidates[0], rows: [], error: lastErr };
}

export async function GET(_req: Request, ctx: any) {
  try {
    const id = await getIdFromCtx(ctx);
    if (!id || id === "PASTE-DEAL-ID-HERE") return NextResponse.json({ ok: false, error: "Missing deal id" }, { status: 400 });

    const supabase = getSupabase();

    let dealRes = await supabase.from("deals").select("*").eq("id", id).maybeSingle();
    if (!dealRes.data && !dealRes.error) dealRes = await supabase.from("deals").select("*").ilike("deal_code", id).maybeSingle();

    if (dealRes.error) return NextResponse.json({ ok: false, error: dealRes.error.message }, { status: 500 });
    if (!dealRes.data) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const deal = dealRes.data;
    const banksRes = await loadBanks(supabase, deal.id);
    const merged = { ...deal, banks: banksRes.rows };

    return NextResponse.json({ ok: true, deal: merged, banks_source: banksRes.table }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}

export async function PATCH(req: Request, ctx: any) {
  try {
    const idOrCode = await getIdFromCtx(ctx);
    if (!idOrCode) return NextResponse.json({ ok: false, error: "Missing deal id" }, { status: 400 });

    const raw = await req.json().catch(() => ({}));
    const payload = sanitizeDealPatch(normalizeDealPatchShape(raw));

    const supabase = getSupabase();

    // 1) Resolve real deal id (supports UUID or deal_code)
    let idRes = await supabase.from("deals").select("id").eq("id", idOrCode).maybeSingle();
    if (!idRes.data && !idRes.error) idRes = await supabase.from("deals").select("id").ilike("deal_code", idOrCode).maybeSingle();

    if (idRes.error) return NextResponse.json({ ok: false, error: idRes.error.message }, { status: 500 });
    if (!idRes.data?.id) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const dealId = idRes.data.id;

    // 2) Update
    const upd = await supabase.from("deals").update(payload).eq("id", dealId).select("*").maybeSingle();

    if (upd.error) {
      console.error("DEALS_PATCH_SUPABASE_ERROR:", upd.error);
      return NextResponse.json({ ok: false, error: upd.error.message }, { status: 500 });
    }

    // If deal exists but update returns no row, that's usually RLS / permissions / wrong key
    if (!upd.data) {
      return NextResponse.json(
        {
          ok: false,
          error:
            "Update returned no rows. Deal exists, but update was blocked (likely RLS / permissions). Ensure SUPABASE_SERVICE_ROLE_KEY is set in .env.local for server routes.",
        },
        { status: 403 }
      );
    }

    const banksRes = await loadBanks(supabase, upd.data.id);
    const merged = { ...upd.data, banks: banksRes.rows };

    return NextResponse.json({ ok: true, deal: merged, banks_source: banksRes.table }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}