import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic";

function getSupabase() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL || "";
  const key =
    process.env.SUPABASE_SERVICE_ROLE_KEY ||
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ||
    process.env.SUPABASE_ANON_KEY ||
    "";

  if (!url || !key) throw new Error("Missing Supabase env vars (URL/KEY). Check .env.local");
  return createClient(url, key, { auth: { persistSession: false } });
}

function isUuid(v: string) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);
}

async function getParamId(ctx: any) {
  const params = await (ctx as any)?.params;
  const raw = String(params?.id ?? "").trim();
  try { return decodeURIComponent(raw).trim(); } catch { return raw.trim(); }
}

function sanitizeDealPatch(input: any) {
  if (!input || typeof input !== "object") return {};
  const out: any = { ...input };

  // --- kill anything that is NOT a deals table column ---
  const kill = [
    "banks",
    "banks_source",
    "bankNotes",     // <-- THIS is your current crash
    "nextStage",     // move payload key
    "note",          // move payload key
    "id",
  ];
  for (const k of kill) if (k in out) delete out[k];

  // never allow these from client
  if ("created_at" in out) delete out.created_at;
  if ("updated_at" in out) delete out.updated_at;
  if ("deal_code" in out) delete out.deal_code;

  // Dates: Supabase date columns cannot accept ""
  const dateKeys = ["submitted_date", "payment_due_date"];
  for (const k of dateKeys) {
    if (k in out && (out[k] === "" || out[k] === undefined)) out[k] = null;
  }

  // Timestamps: cannot accept ""
  const tsKeys = ["last_moved_at"];
  for (const k of tsKeys) {
    if (k in out && (out[k] === "" || out[k] === undefined)) out[k] = null;
  }

  // Numbers: "" -> null, numeric strings -> number
  const numKeys = ["amount_zar", "amount"];
  for (const k of numKeys) {
    if (k in out) {
      const v = out[k];
      if (v === "" || v === undefined) out[k] = null;
      else if (typeof v === "string" && v.trim() !== "" && !Number.isNaN(Number(v))) out[k] = Number(v);
    }
  }

  // Booleans: "true"/"false" -> boolean, "" -> null
  const boolKeys = ["agent_comm_paid"];
  for (const k of boolKeys) {
    if (k in out) {
      const v = out[k];
      if (v === "" || v === undefined) out[k] = null;
      else if (v === "true") out[k] = true;
      else if (v === "false") out[k] = false;
    }
  }

  return out;
}

async function loadDealByIdOrCode(supabase: any, idOrCode: string) {
  const key = String(idOrCode || "").trim();
  if (!key) return { data: null, error: { message: "Missing deal id/code" } };

  if (isUuid(key)) {
    return await supabase.from("deals").select("*").eq("id", key).maybeSingle();
  }

  // deal_code path e.g. SB-3A310E
  return await supabase.from("deals").select("*").eq("deal_code", key).maybeSingle();
}

async function loadBanks(supabase: any, dealId: string) {
  // Your real table is deal_banks
  const r = await supabase.from("deal_banks").select("*").eq("deal_id", dealId);
  if (r.error) return { rows: [], error: r.error, source: "deal_banks" };
  return { rows: r.data ?? [], error: null, source: "deal_banks" };
}

export async function GET(_req: Request, ctx: any) {
  try {
    const idOrCode = await getParamId(ctx);
    if (!idOrCode) return NextResponse.json({ ok: false, error: "Missing deal id/code" }, { status: 400 });

    const supabase = getSupabase();
    const dealRes = await loadDealByIdOrCode(supabase, idOrCode);

    if (dealRes.error) return NextResponse.json({ ok: false, error: dealRes.error.message }, { status: 500 });
    if (!dealRes.data) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const banksRes = await loadBanks(supabase, dealRes.data.id);
    const merged = { ...dealRes.data, banks: banksRes.rows };

    return NextResponse.json({ ok: true, deal: merged, banks_source: banksRes.source }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}

export async function PATCH(req: Request, ctx: any) {
  try {
    const idOrCode = await getParamId(ctx);
    if (!idOrCode) return NextResponse.json({ ok: false, error: "Missing deal id/code" }, { status: 400 });

    const supabase = getSupabase();

    // resolve deal first (so PATCH works for SB-CODE too)
    const dealRes = await loadDealByIdOrCode(supabase, idOrCode);
    if (dealRes.error) return NextResponse.json({ ok: false, error: dealRes.error.message }, { status: 500 });
    if (!dealRes.data) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const body = await req.json().catch(() => ({}));

    // MOVE MODE: frontend sends { nextStage, note, bankNotes: [] ... }
    let payload: any = {};
    if (body?.nextStage) {
      payload.stage = String(body.nextStage).trim();
      payload.last_moved_at = new Date().toISOString();
      payload.last_moved_by =
        String(body?.movedBy ?? body?.moved_by ?? body?.last_moved_by ?? body?.actor ?? "").trim() || null;

      // optional: allow payment_due_date update if present
      if ("payment_due_date" in body) {
        const v = body.payment_due_date;
        payload.payment_due_date = (v === "" || v === undefined) ? null : v;
      }
    } else {
      payload = sanitizeDealPatch(body);
    }

    // ALWAYS strip bankNotes and other junk, even in move mode
    payload = sanitizeDealPatch(payload);

    const upd = await supabase.from("deals").update(payload).eq("id", dealRes.data.id).select("*").maybeSingle();
    if (upd.error) return NextResponse.json({ ok: false, error: upd.error.message }, { status: 500 });
    if (!upd.data) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const banksRes = await loadBanks(supabase, upd.data.id);
    const merged = { ...upd.data, banks: banksRes.rows };

    return NextResponse.json({ ok: true, deal: merged, banks_source: banksRes.source }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}