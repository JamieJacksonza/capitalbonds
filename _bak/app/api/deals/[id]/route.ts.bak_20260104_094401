import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

function getSupabase() {
  const url =
    process.env.NEXT_PUBLIC_SUPABASE_URL ||
    process.env.SUPABASE_URL ||
    "";

  // IMPORTANT: API routes must use service role (bypasses RLS).
  // If this is missing at runtime, you MUST restart `npm run dev`.
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY || "";

  if (!url) throw new Error("Missing SUPABASE URL. Check .env.local");
  if (!key) throw new Error("Missing SUPABASE_SERVICE_ROLE_KEY at runtime. Restart dev server (Ctrl+C then npm run dev).");

  return createClient(url, key, { auth: { persistSession: false } });
}

function isUuid(v: string) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);
}

async function getIdOrCode(ctx: any) {
  const params = await (ctx as any)?.params;
  const raw = String(params?.id ?? "").trim();
  try { return decodeURIComponent(raw).trim(); } catch { return raw.trim(); }
}

async function resolveDealId(supabase: any, idOrCode: string) {
  const key = String(idOrCode || "").trim();
  if (!key) return null;

  if (isUuid(key)) return key;

  // deal_code lookup (exact first, then ilike fallback)
  let r = await supabase.from("deals").select("id").eq("deal_code", key).maybeSingle();
  if (!r.data && !r.error) {
    r = await supabase.from("deals").select("id").ilike("deal_code", key).maybeSingle();
  }
  if (r.error) throw new Error(r.error.message);
  return r.data?.id ?? null;
}

async function loadBanks(supabase: any, dealId: string) {
  const r = await supabase.from("deal_banks").select("*").eq("deal_id", dealId);
  if (r.error) return { rows: [], source: "deal_banks", error: r.error };
  return { rows: r.data ?? [], source: "deal_banks", error: null };
}

// Only allow REAL columns from public.deals (based on your schema)
const DEALS_ALLOWED = new Set([
  "applicant",
  "bank",
  "amount_zar",
  "consultant",
  "agent_name",
  "attorney",
  "stage",
  "notes",
  "submitted_date",
  "last_moved_by",
  "last_moved_at",
  "applicant_email",
  "applicant_cell",
  "property_address",
  "registration_number",
  "registration_attorney",
  "registration_attorney_tel",
  "registration_attorney_contact",
  "agent_comm_paid",
  "payment_due_date",
]);

function cleanDate(v: any) {
  if (v === "" || v === undefined) return null;
  return v;
}

function sanitizePatch(input: any) {
  if (!input || typeof input !== "object") return {};

  const src: any = { ...input };
  const out: any = {};

  // ---- MOVE payload support ----
  // { nextStage, movedBy, note, bankNotes... } OR { stage, movedBy, ... }
  if ("nextStage" in src && !("stage" in src)) src.stage = src.nextStage;
  if ("next_stage" in src && !("stage" in src)) src.stage = src.next_stage;

  if ("movedBy" in src && !("last_moved_by" in src)) src.last_moved_by = src.movedBy;
  if ("moved_by" in src && !("last_moved_by" in src)) src.last_moved_by = src.moved_by;

  if ("movedAt" in src && !("last_moved_at" in src)) src.last_moved_at = src.movedAt;
  if ("moved_at" in src && !("last_moved_at" in src)) src.last_moved_at = src.moved_at;

  // If stage is being changed and last_moved_at isn't provided, set it.
  if ("stage" in src && !("last_moved_at" in src)) src.last_moved_at = new Date().toISOString();

  // ---- allowlist only ----
  for (const k of Object.keys(src)) {
    if (!DEALS_ALLOWED.has(k)) continue;

    // prevent "" from reaching date columns
    if (k === "submitted_date" || k === "payment_due_date") out[k] = cleanDate(src[k]);
    else out[k] = src[k];
  }

  // never allow these via client
  delete out.created_at;
  delete out.updated_at;
  delete out.deal_code;
  delete out.id;

  return out;
}

export async function GET(_req: Request, ctx: any) {
  try {
    const idOrCode = await getIdOrCode(ctx);
    if (!idOrCode) return NextResponse.json({ ok: false, error: "Missing deal id/code" }, { status: 400 });

    const supabase = getSupabase();
    const dealId = await resolveDealId(supabase, idOrCode);

    if (!dealId) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const dealRes = await supabase.from("deals").select("*").eq("id", dealId).maybeSingle();
    if (dealRes.error) return NextResponse.json({ ok: false, error: dealRes.error.message }, { status: 500 });
    if (!dealRes.data) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const banksRes = await loadBanks(supabase, dealId);

    return NextResponse.json(
      { ok: true, deal: { ...dealRes.data, banks: banksRes.rows }, banks_source: banksRes.source },
      { status: 200 }
    );
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}

export async function PATCH(req: Request, ctx: any) {
  try {
    const idOrCode = await getIdOrCode(ctx);
    if (!idOrCode) return NextResponse.json({ ok: false, error: "Missing deal id/code" }, { status: 400 });

    const supabase = getSupabase();
    const dealId = await resolveDealId(supabase, idOrCode);

    if (!dealId) return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });

    const body = await req.json().catch(() => ({}));

    // Load current deal state for activity logging
    const before = await supabase
      .from("deals")
      .select("id, deal_code, stage")
      .eq("id", dealId)
      .maybeSingle();const payload = sanitizePatch(body);

    if (!Object.keys(payload).length) {
      return NextResponse.json(
        { ok: false, error: "No valid fields to update (payload contained only non-deals keys)." },
        { status: 400 }
      );
    }

    const upd = await supabase
      .from("deals")
      .update(payload)
      .eq("id", dealId)
      .select("*")
      .maybeSingle();

    if (upd.error) {
      console.error("DEALS_PATCH_ERROR:", upd.error);
      return NextResponse.json({ ok: false, error: upd.error.message }, { status: 500 });
    }

    if (!upd.data) {
      // If this happens with service_role, it usually means the row didn't match (or PostgREST returned nothing).
      return NextResponse.json({ ok: false, error: "Deal not found" }, { status: 404 });
    }

    const banksRes = await loadBanks(supabase, upd.data.id);

    return NextResponse.json(
      { ok: true, deal: { ...upd.data, banks: banksRes.rows }, banks_source: banksRes.source },
      { status: 200 }
    );
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}